<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VexFlow Renderer</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: transparent;
        }

        #output {
            width: 100%;
            height: 100vh;
            overflow: auto;
        }
    </style>
    <script src="../js/vexflow.js"></script>
</head>

<body>
    <div id="output"></div>
    const { Factory, Stave, StaveNote, Voice, Formatter, Annotation, StaveConnector, Beam } = Vex.Flow;

    function renderHymn(data) {
    const output = document.getElementById('output');
    output.innerHTML = '';

    const systems = data.systems || [];
    // Base configuration (fallback)
    const globalKeySignature = data.keySignature || 'C';
    const globalTimeSignature = data.timeSignature || '4/4';

    const rendererWidth = window.innerWidth > 0 ? window.innerWidth - 30 : 800; // Defensive width

    // Initialize Factory
    const vf = new Factory({
    renderer: { elementId: 'output', width: rendererWidth, height: systems.length * 280 + 100 }
    });
    const context = vf.getContext();

    let yOffset = 20;
    const leftMargin = 10;
    const totalWidth = rendererWidth - 20;

    systems.forEach((system, systemIndex) => {
    // Find number of measures in this system from the first voice available
    let measuresCount = 0;
    try {
    measuresCount = system.treble.soprano.measures.length;
    } catch (e) {
    try { measuresCount = system.bass.bass.measures.length; } catch(e2) {}
    }

    if (measuresCount === 0) return;

    // Use system-specific signatures if available, else global
    const keySignature = system.keySignature || globalKeySignature;
    const timeSignature = system.timeSignature || globalTimeSignature;

    // Calculate measure width
    // First measure needs extra space for clef/key/time signatures
    const firstMeasureExtra = 70;
    const measureWidth = (totalWidth - firstMeasureExtra) / measuresCount;

    let xCursor = leftMargin;

    for (let m = 0; m < measuresCount; m++) { const currentMeasureWidth=(m===0) ? measureWidth + firstMeasureExtra :
        measureWidth; // 1. Create Staves // Treble Staff const trebleStave=new Stave(xCursor, yOffset,
        currentMeasureWidth); // Bass Staff - Positioned 130px below to allow room for lyrics const bassStave=new
        Stave(xCursor, yOffset + 130, currentMeasureWidth); // Add Clefs/Signatures to first measure if (m===0) {
        trebleStave.addClef('treble').addKeySignature(keySignature).addTimeSignature(timeSignature);
        bassStave.addClef('bass').addKeySignature(keySignature).addTimeSignature(timeSignature); // Add connector new
        StaveConnector(trebleStave, bassStave).setType(StaveConnector.type.BRACE).setContext(context).draw(); new
        StaveConnector(trebleStave, bassStave).setType(StaveConnector.type.SINGLE_LEFT).setContext(context).draw(); }
        else { // Optional: Add clefs on every measure? Standard is just at start of system usually // but VexFlow often
        helps to have them invisibly for spacing or just rely on start. // Let's stick to start of system. } // Add end
        bar lines for the last measure if (m===measuresCount - 1) {
        trebleStave.setEndBarType(Vex.Flow.Barline.type.END); bassStave.setEndBarType(Vex.Flow.Barline.type.END); } //
        Draw staves trebleStave.setContext(context).draw(); bassStave.setContext(context).draw(); // 2. Create Voices //
        Helper to create voice notes const createVoiceNotes=(voiceData, clef)=> {
        if (!voiceData || !voiceData.measures || !voiceData.measures[m]) return [];

        return voiceData.measures[m].map(noteData => {
        const durationMap = { "whole": "w", "half": "h", "quarter": "q", "eighth": "8", "16th": "16" };
        let duration = durationMap[noteData.duration] || "q";

        // Format key: "G4" -> "g/4"
        const k = noteData.note.replace('#', '#');
        const keyPart = k.substring(0, k.length - 1).toLowerCase();
        const octavePart = k.substring(k.length - 1);
        const vfKey = `${keyPart}/${octavePart}`;

        const stoveNoteConfig = {
        keys: [vfKey],
        duration: duration,
        clef: clef,
        };

        const staveNote = new StaveNote(stoveNoteConfig);

        // Add dots
        if (noteData.duration.includes('dotted') || (noteData.note && noteData.note.includes('.'))) {
        // noteData.note usually doesn't have dot in this JSON, logic might need check.
        // JSON doesn't explicit dot property, but duration might be 'dotted-quarter'?
        // Standard MusicXML parser output usually handles duration string.
        // Looking at JSON: "duration": "quarter"
        // If dot is needed, it must be inferred or in data.
        // Looking at sample: "note": "G4", "duration": "quarter".
        // If dot is crucial, maybe it's not in the sample data?
        // Sample data doesn't show dots. We'll skip for now or rely on if 'note' has it.
        }

        // Add Lyrics (Attached to Soprano)
        if (noteData.lyrics && Array.isArray(noteData.lyrics)) {
        noteData.lyrics.forEach((line, i) => {
        // Create Annotation
        if (line) {
        const lyric = new Annotation(line)
        .setFont("Serif", 11, "normal")
        .setVerticalJustification(Annotation.VerticalJustify.BOTTOM);

        staveNote.addModifier(lyric, 0);
        }
        });
        }

        return staveNote;
        });
        };

        const sopranoNotes = createVoiceNotes(system.treble.soprano, 'treble');
        sopranoNotes.forEach(n => n.setStemDirection(1)); // Up

        const altoNotes = createVoiceNotes(system.treble.alto, 'treble');
        altoNotes.forEach(n => n.setStemDirection(-1)); // Down

        const tenorNotes = createVoiceNotes(system.bass.tenor, 'bass');
        tenorNotes.forEach(n => n.setStemDirection(1)); // Up

        const bassNotes = createVoiceNotes(system.bass.bass, 'bass');
        bassNotes.forEach(n => n.setStemDirection(-1)); // Down

        // Create Voices
        const timeSigParts = timeSignature.split('/');
        const numBeats = parseInt(timeSigParts[0]);
        const beatValue = parseInt(timeSigParts[1]);

        const createVoice = (notes) => {
        if (!notes || notes.length === 0) return null;
        // VexFlow needs correct beat count. simpler to use Soft mode or proper calculation
        // But we have explicit measures satisfying time sig usually.
        const v = new Voice({ num_beats: numBeats, beat_value: beatValue });
        v.setMode(Voice.Mode.SOFT); // Allow flexibility if timestamps slightly off
        v.addTickables(notes);
        return v;
        };

        const voices = [];
        const vSoprano = createVoice(sopranoNotes); if(vSoprano) voices.push(vSoprano);
        const vAlto = createVoice(altoNotes); if(vAlto) voices.push(vAlto);
        const vTenor = createVoice(tenorNotes); if(vTenor) voices.push(vTenor);
        const vBass = createVoice(bassNotes); if(vBass) voices.push(vBass);

        // Format
        if (voices.length > 0) {
        new Formatter().joinVoices(voices).format(voices, currentMeasureWidth - 20);
        }

        // Draw
        if(vSoprano) vSoprano.draw(context, trebleStave);
        if(vAlto) vAlto.draw(context, trebleStave);
        if(vTenor) vTenor.draw(context, bassStave);
        if(vBass) vBass.draw(context, bassStave);

        // Beams
        // Basic auto-beaming per voice
        [sopranoNotes, altoNotes, tenorNotes, bassNotes].forEach(notes => {
        if(notes.length > 0) Beam.generateBeams(notes).forEach(b => b.setContext(context).draw());
        });

        xCursor += currentMeasureWidth;
        }

        yOffset += 280; // Margin for next system
        });
        }

        window.renderHymn = renderHymn;
        </script>
</body>

</html>